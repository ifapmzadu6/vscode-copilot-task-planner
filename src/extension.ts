import * as vscode from 'vscode';

/**
 * Input schema for the plan tool
 */
interface PlanToolInput {
    userRequest: string;
    context?: string;
}

/**
 * Question generated by the subagent
 */
interface Question {
    text: string;
    type: 'text' | 'select' | 'multiline';
    options?: string[];
}

/**
 * Collected answer from user
 */
interface CollectedAnswer {
    question: string;
    answer: string;
}

/**
 * Response from question generation subagent
 */
interface QuestionResponse {
    done: boolean;
    question?: Question;
    reason?: string;
}

/**
 * Helper function to invoke runSubagent and extract text result
 */
async function invokeSubagent(
    description: string,
    prompt: string,
    toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
    token: vscode.CancellationToken
): Promise<string> {
    console.log(`[TaskPlanner] invokeSubagent: ${description}`);
    const result = await vscode.lm.invokeTool(
        'runSubagent',
        {
            input: { description, prompt },
            toolInvocationToken
        },
        token
    );

    let responseText = '';
    for (const part of result.content) {
        if (part instanceof vscode.LanguageModelTextPart) {
            responseText += part.value;
        }
    }
    console.log(`[TaskPlanner] invokeSubagent result length: ${responseText.length}`);
    return responseText;
}

/**
 * Task Planner Tool
 * Uses runSubagent + single persistent Webview for dynamic interactive question flow
 */
class TaskPlannerTool implements vscode.LanguageModelTool<PlanToolInput> {

    async invoke(
        options: vscode.LanguageModelToolInvocationOptions<PlanToolInput>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        const { userRequest, context } = options.input;
        console.log(`[TaskPlanner] invoke called with userRequest: ${userRequest}`);

        // Clean the user request to remove tool name prefix
        const cleanRequest = this.cleanUserRequest(userRequest);
        console.log(`[TaskPlanner] cleanRequest: ${cleanRequest}`);

        const collectedAnswers: CollectedAnswer[] = [];

        try {
            // Step 1: Analyze workspace context
            console.log('[TaskPlanner] Step 1: Analyzing workspace context...');
            const workspaceContext = await this.analyzeWorkspaceContext(
                cleanRequest,
                options.toolInvocationToken,
                token
            );
            const fullContext = workspaceContext || context || '';
            console.log(`[TaskPlanner] Workspace context length: ${fullContext.length}`);

            // Step 2: Create persistent Webview panel
            console.log('[TaskPlanner] Step 2: Creating Webview panel...');
            const panel = vscode.window.createWebviewPanel(
                'taskPlanner',
                'Task Planner',
                vscode.ViewColumn.One,
                { enableScripts: true }
            );
            console.log('[TaskPlanner] Webview panel created');

            // Initialize the panel with base HTML
            panel.webview.html = this.generateBaseHtml(cleanRequest);
            console.log('[TaskPlanner] Webview HTML set');

            // Create a promise that resolves when panel is closed or user finishes
            let panelClosed = false;
            panel.onDidDispose(() => {
                console.log('[TaskPlanner] Panel disposed');
                panelClosed = true;
            });

            // Step 3: Dynamic question loop with back support
            console.log('[TaskPlanner] Step 3: Starting question loop...');
            const maxQuestions = 5;
            const questionHistory: { question: Question; response: QuestionResponse }[] = [];
            let currentIndex = 0;

            while (currentIndex < maxQuestions) {
                console.log(`[TaskPlanner] Question loop iteration ${currentIndex + 1}`);

                if (token.isCancellationRequested) {
                    console.log('[TaskPlanner] Cancellation requested');
                    break;
                }
                if (panelClosed) {
                    console.log('[TaskPlanner] Panel was closed');
                    break;
                }

                let questionResponse: QuestionResponse;

                // Check if we're revisiting a previous question
                if (currentIndex < questionHistory.length) {
                    console.log('[TaskPlanner] Using cached question');
                    questionResponse = questionHistory[currentIndex].response;
                } else {
                    // Generate new question based on answers up to current index
                    console.log('[TaskPlanner] Generating new question...');
                    const answersForGeneration = collectedAnswers.slice(0, currentIndex);
                    questionResponse = await this.generateNextQuestion(
                        cleanRequest,
                        fullContext,
                        answersForGeneration,
                        options.toolInvocationToken,
                        token
                    );
                    console.log(`[TaskPlanner] Question response: done=${questionResponse.done}, hasQuestion=${!!questionResponse.question}`);

                    // Check if we have enough information
                    if (questionResponse.done || !questionResponse.question) {
                        console.log(`[TaskPlanner] Breaking loop: done=${questionResponse.done}, reason=${questionResponse.reason}`);
                        break;
                    }

                    // Cache the question
                    questionHistory.push({ question: questionResponse.question, response: questionResponse });
                    console.log(`[TaskPlanner] Cached question: ${questionResponse.question.text}`);
                }

                if (!questionResponse.question) {
                    console.log('[TaskPlanner] No question in response, breaking');
                    break;
                }

                // Send question to Webview and wait for answer
                console.log(`[TaskPlanner] Sending question to Webview: ${questionResponse.question.text}`);
                const result = await this.askQuestionInPanel(
                    panel,
                    questionResponse.question,
                    currentIndex + 1,
                    currentIndex > 0, // canGoBack
                    panelClosed,
                    token
                );
                console.log(`[TaskPlanner] Got result from panel: ${result}`);

                if (result === null) {
                    console.log('[TaskPlanner] User cancelled');
                    panel.dispose();
                    return new vscode.LanguageModelToolResult([
                        new vscode.LanguageModelTextPart('User cancelled the planning process.')
                    ]);
                }

                if (result === '__BACK__') {
                    console.log('[TaskPlanner] User went back');
                    if (currentIndex > 0) {
                        currentIndex--;
                        collectedAnswers.pop();
                        panel.webview.postMessage({ type: 'removeLastQA' });
                    }
                    continue;
                }

                // Store or update answer
                if (currentIndex < collectedAnswers.length) {
                    collectedAnswers[currentIndex] = {
                        question: questionResponse.question.text,
                        answer: result
                    };
                } else {
                    collectedAnswers.push({
                        question: questionResponse.question.text,
                        answer: result
                    });
                }
                console.log(`[TaskPlanner] Stored answer ${currentIndex + 1}: ${result}`);

                // Update panel to show the answered question
                panel.webview.postMessage({
                    type: 'questionAnswered',
                    questionNum: currentIndex + 1,
                    question: questionResponse.question.text,
                    answer: result
                });

                currentIndex++;
            }

            console.log(`[TaskPlanner] Question loop finished. Collected ${collectedAnswers.length} answers`);

            // Send completion message to panel
            panel.webview.postMessage({ type: 'generating' });

            // Step 4: Generate and confirm refined prompt
            console.log('[TaskPlanner] Step 4: Generating refined prompt...');
            let refinedPrompt = await this.generateRefinedPrompt(
                cleanRequest,
                fullContext,
                collectedAnswers,
                options.toolInvocationToken,
                token
            );
            console.log(`[TaskPlanner] Refined prompt length: ${refinedPrompt.length}`);

            // Step 5: Plan confirmation loop
            console.log('[TaskPlanner] Step 5: Plan confirmation loop...');
            let confirmed = false;
            while (!confirmed && !panelClosed && !token.isCancellationRequested) {
                const confirmResult = await this.showPlanConfirmation(panel, refinedPrompt, panelClosed, options.toolInvocationToken, token);
                console.log(`[TaskPlanner] Confirmation result: ${confirmResult?.type}`);

                if (confirmResult === null) {
                    // User cancelled
                    panel.dispose();
                    return new vscode.LanguageModelToolResult([
                        new vscode.LanguageModelTextPart('User cancelled the planning process.')
                    ]);
                }

                if (confirmResult.type === 'approve') {
                    confirmed = true;
                } else if (confirmResult.type === 'revise' && confirmResult.feedback) {
                    // Revise the plan based on feedback
                    console.log(`[TaskPlanner] Revising plan with feedback: ${confirmResult.feedback}`);
                    panel.webview.postMessage({ type: 'revising' });

                    refinedPrompt = await this.revisePlan(
                        refinedPrompt,
                        confirmResult.feedback,
                        options.toolInvocationToken,
                        token
                    );
                    console.log(`[TaskPlanner] Revised prompt length: ${refinedPrompt.length}`);
                }
            }

            // Step 6: Register tasks to manage_todo_list
            console.log('[TaskPlanner] Step 6: Registering tasks to todo list...');
            await this.registerTasksToTodoList(
                refinedPrompt,
                options.toolInvocationToken,
                token
            );

            // Close the panel
            console.log('[TaskPlanner] Closing panel');
            panel.dispose();

            console.log('[TaskPlanner] Returning refined prompt');
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(refinedPrompt)
            ]);

        } catch (error) {
            console.error('[TaskPlanner] Error:', error);
            if (error instanceof Error && error.message === 'Cancelled by user') {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('User cancelled the planning process.')
                ]);
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`Error during planning: ${errorMessage}`)
            ]);
        }
    }

    /**
     * Analyzes the current workspace context
     */
    private async analyzeWorkspaceContext(
        userRequest: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string | undefined> {
        try {
            const prompt = `Analyze the current workspace for this request: "${userRequest}"
Look at: workspace structure, tech stack, relevant files, existing patterns.
Provide a concise summary (max 150 words) focusing on relevant information.`;

            const context = await invokeSubagent(
                'Analyze workspace context',
                prompt,
                toolInvocationToken,
                token
            );
            return context || undefined;
        } catch (error) {
            console.error('[TaskPlanner] analyzeWorkspaceContext error:', error);
            return undefined;
        }
    }

    /**
     * Generates the next question based on collected answers
     */
    private async generateNextQuestion(
        userRequest: string,
        context: string,
        collectedAnswers: CollectedAnswer[],
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<QuestionResponse> {
        const answersText = collectedAnswers.length > 0
            ? collectedAnswers.map((a, i) => `Q${i + 1}: ${a.question}\nA${i + 1}: ${a.answer}`).join('\n\n')
            : 'No questions asked yet.';

        const prompt = `You are a task planning assistant. Generate the NEXT clarifying question.

## User Request
${userRequest}

## Context
${context}

## Previous Q&A
${answersText}

## Your Task
Before generating a question, you MAY investigate the workspace or use other tools if needed to understand the project better.
Then decide if you need more information. Ask about:
- Goals and success criteria
- Scope and boundaries
- Technical constraints
- Dependencies or risks

## Language Rule
IMPORTANT: Respond in the SAME LANGUAGE as the user's request. If the user wrote in Japanese, generate the question and options in Japanese. If in English, use English.

## Question Format Rules
- ALWAYS use "select" type with exactly 4 options
- Make options specific and relevant to THIS project based on your investigation
- The 5th "Other" option will be automatically added by the UI

## Output (JSON only)
If enough info: {"done": true, "reason": "brief reason"}
If need more: {"done": false, "question": {"text": "Question?", "type": "select", "options": ["Option 1", "Option 2", "Option 3", "Option 4"] }}

Return ONLY valid JSON.`;

        console.log('[TaskPlanner] generateNextQuestion prompt sent');
        const response = await invokeSubagent(
            'Generate next question',
            prompt,
            toolInvocationToken,
            token
        );
        console.log(`[TaskPlanner] generateNextQuestion raw response: ${response.substring(0, 200)}...`);

        try {
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]) as QuestionResponse;
                console.log(`[TaskPlanner] Parsed response: done=${parsed.done}, question=${parsed.question?.text || 'none'}`);
                return parsed;
            }
            console.log('[TaskPlanner] Could not find JSON in response');
            return { done: true, reason: 'Could not parse response' };
        } catch (parseError) {
            console.error('[TaskPlanner] JSON parse error:', parseError);
            return { done: true, reason: 'Parse error' };
        }
    }

    /**
     * Sends a question to the panel and waits for the answer
     */
    private askQuestionInPanel(
        panel: vscode.WebviewPanel,
        question: Question,
        questionNum: number,
        canGoBack: boolean,
        panelClosed: boolean,
        token: vscode.CancellationToken
    ): Promise<string | null> {
        console.log(`[TaskPlanner] askQuestionInPanel: Q${questionNum}, canGoBack=${canGoBack}, panelClosed=${panelClosed}`);
        return new Promise((resolve) => {
            if (panelClosed) {
                console.log('[TaskPlanner] Panel already closed, resolving null');
                resolve(null);
                return;
            }

            let resolved = false;
            const safeResolve = (value: string | null) => {
                if (!resolved) {
                    resolved = true;
                    disposeAll();
                    resolve(value);
                }
            };

            const disposables: vscode.Disposable[] = [];
            const disposeAll = () => {
                disposables.forEach(d => d.dispose());
                disposables.length = 0;
            };

            // Send the new question to the Webview
            console.log('[TaskPlanner] Posting newQuestion message to Webview');
            panel.webview.postMessage({
                type: 'newQuestion',
                questionNum,
                question,
                canGoBack
            });

            // Listen for the answer
            const messageDisposable = panel.webview.onDidReceiveMessage(message => {
                console.log(`[TaskPlanner] Received message from Webview: ${JSON.stringify(message)}`);
                if (message.type === 'answer') {
                    safeResolve(message.answer);
                } else if (message.type === 'back') {
                    safeResolve('__BACK__');
                } else if (message.type === 'cancel') {
                    safeResolve(null);
                }
            });
            disposables.push(messageDisposable);

            // If panel closes, resolve null
            const panelDisposable = panel.onDidDispose(() => {
                console.log('[TaskPlanner] Panel disposed while waiting for answer');
                safeResolve(null);
            });
            disposables.push(panelDisposable);

            // Listen for cancellation token
            const tokenDisposable = token.onCancellationRequested(() => {
                console.log('[TaskPlanner] Cancellation requested while waiting for answer');
                safeResolve(null);
            });
            disposables.push(tokenDisposable);
        });
    }

    /**
     * Shows the plan for user confirmation
     */
    private showPlanConfirmation(
        panel: vscode.WebviewPanel,
        plan: string,
        panelClosed: boolean,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<{ type: 'approve' | 'revise'; feedback?: string } | null> {
        console.log('[TaskPlanner] showPlanConfirmation');

        let currentDisplayPlan = plan;
        let isTranslated = false;

        const sendPlan = () => {
            panel.webview.postMessage({
                type: 'showPlan',
                plan: currentDisplayPlan,
                isTranslated
            });
        };

        return new Promise((resolve) => {
            if (panelClosed) {
                resolve(null);
                return;
            }

            let resolved = false;
            const disposables: vscode.Disposable[] = [];
            const disposeAll = () => {
                disposables.forEach(d => d.dispose());
                disposables.length = 0;
            };

            const safeResolve = (value: { type: 'approve' | 'revise'; feedback?: string } | null) => {
                if (!resolved) {
                    resolved = true;
                    disposeAll();
                    resolve(value);
                }
            };

            sendPlan();

            const messageDisposable = panel.webview.onDidReceiveMessage(async message => {
                console.log(`[TaskPlanner] Plan confirmation message: ${JSON.stringify(message)}`);
                if (message.type === 'approvePlan') {
                    safeResolve({ type: 'approve' });
                } else if (message.type === 'revisePlan') {
                    safeResolve({ type: 'revise', feedback: message.feedback });
                } else if (message.type === 'translatePlan') {
                    // Translate to user's language
                    panel.webview.postMessage({ type: 'translating' });
                    try {
                        const translated = await this.translatePlan(plan, message.targetLang, toolInvocationToken, token);
                        if (!resolved) {
                            currentDisplayPlan = translated;
                            isTranslated = true;
                            sendPlan();
                        }
                    } catch (error) {
                        console.error('[TaskPlanner] Translation error:', error);
                        if (!resolved) {
                            sendPlan(); // Show current plan on error
                        }
                    }
                } else if (message.type === 'showOriginal') {
                    if (!resolved) {
                        currentDisplayPlan = plan;
                        isTranslated = false;
                        sendPlan();
                    }
                } else if (message.type === 'cancel') {
                    safeResolve(null);
                }
            });
            disposables.push(messageDisposable);

            const panelDisposable = panel.onDidDispose(() => {
                console.log('[TaskPlanner] Panel disposed while waiting for plan confirmation');
                safeResolve(null);
            });
            disposables.push(panelDisposable);

            // Listen for cancellation token
            const tokenDisposable = token.onCancellationRequested(() => {
                console.log('[TaskPlanner] Cancellation requested while waiting for plan confirmation');
                safeResolve(null);
            });
            disposables.push(tokenDisposable);
        });
    }

    /**
     * Translates the plan to a target language
     */
    private async translatePlan(
        plan: string,
        targetLang: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        console.log(`[TaskPlanner] Translating plan to ${targetLang}`);
        const prompt = `Translate the following task plan to ${targetLang}. Keep the same structure and format.

${plan}

Return ONLY the translated plan.`;

        const result = await invokeSubagent(
            `Translate plan to ${targetLang}`,
            prompt,
            toolInvocationToken,
            token
        );

        return result || plan;
    }

    /**
     * Revises the plan based on user feedback
     */
    private async revisePlan(
        currentPlan: string,
        feedback: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        const prompt = `Revise the following task plan based on user feedback.

## Current Plan
${currentPlan}

## User Feedback
${feedback}

## Instructions
- Apply the user's feedback to modify the plan
- Keep the same structure and format
- Respond in the same language as the current plan
- Return ONLY the revised plan, no explanations`;

        const result = await invokeSubagent(
            'Revise plan based on feedback',
            prompt,
            toolInvocationToken,
            token
        );

        return result || currentPlan;
    }

    /**
     * Generates the base HTML for the Webview
     */
    private generateBaseHtml(userRequest: string): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Planner</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--vscode-font-family, -apple-system, BlinkMacSystemFont, sans-serif);
            font-size: var(--vscode-font-size, 13px);
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 16px;
            line-height: 1.4;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border));
        }
        .header-icon {
            font-size: 16px;
        }
        .header-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--vscode-foreground);
        }
        .task-info {
            background: var(--vscode-textBlockQuote-background);
            border-left: 2px solid var(--vscode-textLink-activeForeground);
            padding: 8px 12px;
            margin-bottom: 16px;
            font-size: 12px;
            color: var(--vscode-descriptionForeground);
        }
        .task-info strong { color: var(--vscode-foreground); }
        .qa-history { margin-bottom: 12px; }
        .qa-item {
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .qa-item .q {
            color: var(--vscode-textLink-foreground);
            font-weight: 500;
            margin-bottom: 4px;
        }
        .qa-item .a { color: var(--vscode-foreground); }
        .question-panel {
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-focusBorder);
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 12px;
        }
        .question-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--vscode-descriptionForeground);
            margin-bottom: 6px;
        }
        .question-text {
            font-size: 13px;
            color: var(--vscode-foreground);
            margin-bottom: 12px;
            font-weight: 500;
        }
        .options-list { display: flex; flex-direction: column; gap: 6px; }
        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 3px;
            cursor: pointer;
            transition: border-color 0.1s, background 0.1s;
        }
        .option-item:hover {
            background: var(--vscode-list-hoverBackground);
            border-color: var(--vscode-focusBorder);
        }
        .option-item input[type="radio"] {
            accent-color: var(--vscode-focusBorder);
        }
        .option-item.other-option {
            flex-wrap: wrap;
        }
        .option-item.other-option input[type="text"] {
            flex: 1;
            min-width: 150px;
            margin-left: 4px;
        }
        input[type="text"], textarea {
            width: 100%;
            padding: 6px 8px;
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-input-border);
            color: var(--vscode-input-foreground);
            border-radius: 2px;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }
        input[type="text"]:focus, textarea:focus {
            border-color: var(--vscode-focusBorder);
        }
        textarea { resize: vertical; min-height: 60px; }
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        button {
            padding: 6px 14px;
            border-radius: 2px;
            font-size: 13px;
            cursor: pointer;
            border: none;
            font-family: inherit;
        }
        .btn-primary {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }
        .btn-primary:hover { background: var(--vscode-button-hoverBackground); }
        .btn-secondary {
            background: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        .btn-secondary:hover { background: var(--vscode-button-secondaryHoverBackground); }
        .status-panel {
            display: none;
            text-align: center;
            padding: 24px;
            color: var(--vscode-descriptionForeground);
            font-size: 12px;
        }
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--vscode-input-border);
            border-top-color: var(--vscode-focusBorder);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="header">
        <span class="header-icon">üìã</span>
        <span class="header-title">Task Planner</span>
    </div>
    <div class="task-info">
        <strong>Task:</strong> ${this.escapeHtml(userRequest)}
    </div>
    
    <div id="qa-history" class="qa-history"></div>
    
    <div id="current-question" class="question-panel" style="display: none;">
        <div class="question-label">Question <span id="q-num">1</span></div>
        <div class="question-text" id="q-text"></div>
        <div class="options-list" id="input-area"></div>
        <div class="button-row">
            <button type="button" class="btn-secondary" id="backBtn" style="display: none;">‚Üê Back</button>
            <button type="button" class="btn-primary" id="submitBtn">Continue</button>
            <button type="button" class="btn-secondary" id="cancelBtn">Cancel</button>
        </div>
    </div>
    
    <div id="status" class="status-panel">
        <span class="spinner"></span>
        <span id="status-text">Analyzing workspace...</span>
    </div>
    
    <div id="plan-panel" class="question-panel" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <div class="question-label" style="margin-bottom: 0;">Generated Plan</div>
            <div id="lang-toggle" style="display: flex; gap: 4px; align-items: center;">
                <span style="font-size: 11px; color: var(--vscode-descriptionForeground);">üåê</span>
                <select id="lang-select" style="padding: 4px 8px; font-size: 11px; background: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 2px; cursor: pointer;">
                    <option value="English">English (Original)</option>
                    <option value="Japanese">Êó•Êú¨Ë™û</option>
                    <option value="Chinese Simplified">ÁÆÄ‰Ωì‰∏≠Êñá</option>
                    <option value="Chinese Traditional">ÁπÅÈ´î‰∏≠Êñá</option>
                    <option value="Korean">ÌïúÍµ≠Ïñ¥</option>
                    <option value="French">Fran√ßais</option>
                    <option value="German">Deutsch</option>
                    <option value="Italian">Italiano</option>
                    <option value="Spanish">Espa√±ol</option>
                    <option value="Russian">–†—É—Å—Å–∫–∏–π</option>
                    <option value="Portuguese Brazilian">Portugu√™s (Brasil)</option>
                    <option value="Polish">Polski</option>
                    <option value="Turkish">T√ºrk√ße</option>
                    <option value="Czech">ƒåe≈°tina</option>
                </select>
            </div>
        </div>
        <div id="plan-content" style="white-space: pre-wrap; font-size: 12px; max-height: 400px; overflow-y: auto; background: var(--vscode-editor-background); padding: 12px; border-radius: 4px; margin-bottom: 12px;"></div>
        <div id="feedback-section" style="display: none; margin-bottom: 12px;">
            <div class="question-label">Revision Request</div>
            <textarea id="feedback-text" rows="3" placeholder="Enter your feedback..."></textarea>
        </div>
        <div class="button-row">
            <button type="button" class="btn-primary" id="approveBtn">‚úì Approve</button>
            <button type="button" class="btn-secondary" id="reviseBtn">‚úé Revise</button>
            <button type="button" class="btn-secondary" id="planCancelBtn">Cancel</button>
        </div>
    </div>
    
    <script>
        const vscode = acquireVsCodeApi();
        const qaHistory = document.getElementById('qa-history');
        const currentQuestion = document.getElementById('current-question');
        const qNum = document.getElementById('q-num');
        const qText = document.getElementById('q-text');
        const inputArea = document.getElementById('input-area');
        const status = document.getElementById('status');
        const statusText = document.getElementById('status-text');
        const submitBtn = document.getElementById('submitBtn');
        const backBtn = document.getElementById('backBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        
        let currentQuestionData = null;
        
        // Show initial loading state
        status.style.display = 'block';
        
        window.addEventListener('message', event => {
            const message = event.data;
            
            if (message.type === 'newQuestion') {
                currentQuestionData = message.question;
                qNum.textContent = message.questionNum;
                qText.textContent = message.question.text;
                inputArea.innerHTML = createInputField(message.question);
                currentQuestion.style.display = 'block';
                status.style.display = 'none';
                
                // Show/hide back button
                backBtn.style.display = message.canGoBack ? 'inline-block' : 'none';
                
                // Focus on the input
                const input = inputArea.querySelector('input, textarea');
                if (input) input.focus();
            }
            else if (message.type === 'questionAnswered') {
                const item = document.createElement('div');
                item.className = 'qa-item';
                item.innerHTML = '<div class="q">Q' + message.questionNum + ': ' + escapeHtml(message.question) + '</div>' +
                                 '<div class="a">' + escapeHtml(message.answer) + '</div>';
                qaHistory.appendChild(item);
                
                currentQuestion.style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Thinking of next question...';
            }
            else if (message.type === 'removeLastQA') {
                if (qaHistory.lastChild) {
                    qaHistory.removeChild(qaHistory.lastChild);
                }
            }
            else if (message.type === 'generating') {
                currentQuestion.style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Generating detailed plan...';
            }
            else if (message.type === 'showPlan') {
                currentQuestion.style.display = 'none';
                status.style.display = 'none';
                document.getElementById('plan-panel').style.display = 'block';
                document.getElementById('plan-content').textContent = message.plan;
                document.getElementById('feedback-section').style.display = 'none';
                document.getElementById('feedback-text').value = '';

                // Update language select to reflect current state
                if (!message.isTranslated) {
                    document.getElementById('lang-select').value = 'English';
                }
            }
            else if (message.type === 'translating') {
                document.getElementById('plan-panel').style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Translating plan...';
            }
            else if (message.type === 'revising') {
                document.getElementById('plan-panel').style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Revising plan based on feedback...';
            }
        });
        
        backBtn.addEventListener('click', () => {
            vscode.postMessage({ type: 'back' });
        });
        
        document.getElementById('approveBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'approvePlan' });
        });
        
        document.getElementById('reviseBtn').addEventListener('click', () => {
            const feedbackSection = document.getElementById('feedback-section');
            const feedbackText = document.getElementById('feedback-text');
            
            if (feedbackSection.style.display === 'none') {
                feedbackSection.style.display = 'block';
                feedbackText.focus();
            } else {
                const feedback = feedbackText.value.trim();
                if (feedback) {
                    vscode.postMessage({ type: 'revisePlan', feedback: feedback });
                }
            }
        });
        
        document.getElementById('planCancelBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'cancel' });
        });
        
        document.getElementById('lang-select').addEventListener('change', (e) => {
            const lang = e.target.value;
            if (lang === 'English') {
                vscode.postMessage({ type: 'showOriginal' });
            } else {
                vscode.postMessage({ type: 'translatePlan', targetLang: lang });
            }
        });
        
        function createInputField(question) {
            if (question.type === 'select' && question.options) {
                return question.options.map(opt => 
                    '<label class="option-item"><input type="radio" name="answer" value="' + escapeHtml(opt) + '"> ' + escapeHtml(opt) + '</label>'
                ).join('') +
                '<label class="option-item other-option"><input type="radio" name="answer" value="__OTHER__"> Other: <input type="text" id="other-text" placeholder="Enter your answer..." onclick="document.querySelector(\\'input[value=__OTHER__]\\').checked = true;"></label>';
            } else if (question.type === 'multiline') {
                return '<textarea id="answer" rows="3" placeholder="Your answer..."></textarea>';
            } else {
                return '<input type="text" id="answer" placeholder="Your answer...">';
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function getAnswer() {
            const radio = inputArea.querySelector('input[type="radio"]:checked');
            if (radio) {
                if (radio.value === '__OTHER__') {
                    const otherText = document.getElementById('other-text');
                    return otherText ? otherText.value : '';
                }
                return radio.value;
            }
            const input = inputArea.querySelector('input, textarea');
            return input ? input.value : '';
        }
        
        submitBtn.addEventListener('click', () => {
            const answer = getAnswer();
            if (answer.trim()) {
                vscode.postMessage({ type: 'answer', answer: answer });
            }
        });
        
        cancelBtn.addEventListener('click', () => {
            vscode.postMessage({ type: 'cancel' });
        });
        
        // Handle Enter key for text inputs
        inputArea.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && currentQuestionData?.type !== 'multiline') {
                e.preventDefault();
                submitBtn.click();
            }
        });
    </script>
</body>
</html>`;
    }

    /**
     * Cleans the user request by removing tool name prefixes
     */
    private cleanUserRequest(request: string): string {
        return request
            .replace(/^#?plan\s*/i, '')  // Remove #plan or plan prefix
            .replace(/^['"]plan['"]\s*/i, '')  // Remove 'plan' or "plan" prefix
            .trim();
    }

    private escapeHtml(text: string): string {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    /**
     * Generates the final refined prompt
     */
    private async generateRefinedPrompt(
        userRequest: string,
        context: string,
        answers: CollectedAnswer[],
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        const answersText = answers.map((a, i) => `Q${i + 1}: ${a.question}\nA${i + 1}: ${a.answer}`).join('\n\n');
        const bq = '`';
        const mdBlock = bq + bq + bq;

        const prompt = `Generate a comprehensive task prompt:

## Request
${userRequest}

## Context
${context}

## Q&A
${answersText}

## Format
${mdBlock}
# Task: [Name]

## Overview
[What and why]

## Goals
- [Goal 1]
- [Goal 2]

## Scope
- [Areas to modify]

## Approach
- [Technical approach]

## Completion Criteria
- [How to verify]

## Steps
1. [Step 1]
2. [Step 2]
${mdBlock}

Be specific and actionable.`;

        const result = await invokeSubagent(
            'Generate task prompt',
            prompt,
            toolInvocationToken,
            token
        );

        if (!result) throw new Error('No response');
        return result;
    }

    /**
     * Registers tasks to the manage_todo_list tool via runSubagent
     */
    private async registerTasksToTodoList(
        refinedPrompt: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<void> {
        try {
            const prompt = `You are a task registration assistant.

Extract the implementation steps from the following task plan and register each step as a todo item using the manage_todo_list tool.

## Task Plan
${refinedPrompt}

## Instructions
1. Extract all numbered steps from the "## Steps" section
2. Use the manage_todo_list tool to add each step as a todo item
3. After registering, confirm completion

Do NOT output the full plan in chat. Just register the todos and confirm.`;

            await invokeSubagent(
                'Register tasks to todo list',
                prompt,
                toolInvocationToken,
                token
            );

            console.log('[TaskPlanner] Registered tasks to todo list via subagent');
        } catch (error) {
            console.error('[TaskPlanner] Failed to register tasks to todo list:', error);
        }
    }

    async prepareInvocation(
        options: vscode.LanguageModelToolInvocationPrepareOptions<PlanToolInput>,
        _token: vscode.CancellationToken
    ): Promise<vscode.PreparedToolInvocation> {
        const { userRequest } = options.input;
        return {
            invocationMessage: `Planning: "${userRequest.substring(0, 50)}${userRequest.length > 50 ? '...' : ''}"`,
        };
    }
}

export function activate(context: vscode.ExtensionContext) {
    console.log('[TaskPlanner] Extension activated');
    const tool = new TaskPlannerTool();
    context.subscriptions.push(vscode.lm.registerTool('plan', tool));
}

export function deactivate() {
    console.log('[TaskPlanner] Extension deactivated');
}

import * as vscode from 'vscode';

// ============================================================
// Constants - Message Types
// ============================================================

/**
 * Message types sent from extension to Webview
 */
const ExtensionMessage = {
    NEW_QUESTION: 'newQuestion',
    QUESTION_ANSWERED: 'questionAnswered',
    REMOVE_LAST_QA: 'removeLastQA',
    GENERATING: 'generating',
    SHOW_PLAN: 'showPlan',
    TRANSLATING: 'translating',
    REVISING: 'revising',
} as const;

/**
 * Message types sent from Webview to extension
 */
const WebviewMessage = {
    ANSWER: 'answer',
    BACK: 'back',
    CANCEL: 'cancel',
    APPROVE_PLAN: 'approvePlan',
    REVISE_PLAN: 'revisePlan',
    TRANSLATE_PLAN: 'translatePlan',
    SHOW_ORIGINAL: 'showOriginal',
} as const;

// ============================================================
// Configuration Constants
// ============================================================

const Config = {
    /** Timeout for subagent invocations (30 seconds) */
    SUBAGENT_TIMEOUT_MS: 30000,
    /** Maximum retry attempts for JSON parsing */
    MAX_JSON_PARSE_RETRIES: 2,
    /** Maximum number of questions to ask */
    MAX_QUESTIONS: 5,
} as const;

// ============================================================
// Types
// ============================================================

/**
 * Input schema for the plan tool
 */
interface PlanToolInput {
    userRequest: string;
    context?: string;
}

/**
 * Question generated by the subagent
 */
interface Question {
    text: string;
    type: 'text' | 'select' | 'multiline';
    options?: string[];
}

/**
 * Collected answer from user
 */
interface CollectedAnswer {
    question: string;
    answer: string;
}

/**
 * Response from question generation subagent
 */
interface QuestionResponse {
    done: boolean;
    question?: Question;
    reason?: string;
}

// ============================================================
// Helper Functions
// ============================================================

/**
 * Error thrown when a subagent invocation times out
 */
class SubagentTimeoutError extends Error {
    constructor(description: string, timeoutMs: number) {
        super(`Subagent "${description}" timed out after ${timeoutMs}ms`);
        this.name = 'SubagentTimeoutError';
    }
}

/**
 * Helper function to invoke runSubagent with timeout and extract text result
 */
async function invokeSubagent(
    description: string,
    prompt: string,
    toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
    token: vscode.CancellationToken,
    timeoutMs: number = Config.SUBAGENT_TIMEOUT_MS
): Promise<string> {
    console.log(`[TaskPlanner] invokeSubagent: ${description}`);

    // Create timeout promise
    const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => {
            reject(new SubagentTimeoutError(description, timeoutMs));
        }, timeoutMs);
    });

    // Create the actual invocation promise
    const invocationPromise = (async () => {
        const result = await vscode.lm.invokeTool(
            'runSubagent',
            {
                input: { description, prompt },
                toolInvocationToken
            },
            token
        );

        let responseText = '';
        for (const part of result.content) {
            if (part instanceof vscode.LanguageModelTextPart) {
                responseText += part.value;
            }
        }
        console.log(`[TaskPlanner] invokeSubagent result length: ${responseText.length}`);
        return responseText;
    })();

    // Race between invocation and timeout
    return Promise.race([invocationPromise, timeoutPromise]);
}

/**
 * Safely post a message to a webview panel.
 * Returns false if the panel is disposed or posting fails.
 */
function safePostMessage(panel: vscode.WebviewPanel, message: unknown): boolean {
    try {
        panel.webview.postMessage(message);
        return true;
    } catch (error) {
        // Panel is likely disposed
        console.log('[TaskPlanner] Failed to post message (panel may be disposed):', error);
        return false;
    }
}

/**
 * Message handler configuration for createPanelPromise
 */
interface MessageHandler<T> {
    /** The message type to handle */
    type: string;
    /** Handler function that returns the resolved value, or undefined to not resolve */
    handle: (message: Record<string, unknown>) => T | undefined | Promise<T | undefined>;
}

/**
 * Attempts to parse JSON from a response string with retry logic.
 * Tries to extract JSON object from the response and parse it.
 * @param response - The raw response string
 * @param validator - Optional function to validate the parsed object
 * @returns The parsed object or null if parsing fails after retries
 */
function parseJsonWithRetry<T>(
    response: string,
    validator?: (obj: unknown) => obj is T
): T | null {
    // Try to find JSON object in the response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
        console.log('[TaskPlanner] Could not find JSON in response');
        return null;
    }

    const jsonStr = jsonMatch[0];

    for (let attempt = 0; attempt < Config.MAX_JSON_PARSE_RETRIES; attempt++) {
        try {
            const parsed = JSON.parse(jsonStr);

            // Validate if validator is provided
            if (validator && !validator(parsed)) {
                console.log(`[TaskPlanner] JSON validation failed on attempt ${attempt + 1}`);
                continue;
            }

            return parsed as T;
        } catch (error) {
            console.error(`[TaskPlanner] JSON parse error on attempt ${attempt + 1}:`, error);

            // On last attempt, try to fix common JSON issues
            if (attempt === Config.MAX_JSON_PARSE_RETRIES - 1) {
                try {
                    // Try fixing common issues like trailing commas
                    const fixedJson = jsonStr
                        .replace(/,\s*}/g, '}')
                        .replace(/,\s*]/g, ']');
                    const parsed = JSON.parse(fixedJson);
                    if (!validator || validator(parsed)) {
                        return parsed as T;
                    }
                } catch {
                    // Give up
                }
            }
        }
    }

    return null;
}

/**
 * Creates a Promise that listens to Webview messages and resolves based on handlers.
 * Automatically handles disposal and cancellation.
 */
function createPanelPromise<T>(
    panel: vscode.WebviewPanel,
    handlers: MessageHandler<T | null>[],
    token: vscode.CancellationToken,
    onSetup?: () => void
): Promise<T | null> {
    return new Promise((resolve) => {
        let resolved = false;
        const disposables: vscode.Disposable[] = [];

        const disposeAll = () => {
            disposables.forEach(d => d.dispose());
            disposables.length = 0;
        };

        const safeResolve = (value: T | null) => {
            if (!resolved) {
                resolved = true;
                disposeAll();
                resolve(value);
            }
        };

        // Call setup callback if provided
        if (onSetup) {
            onSetup();
        }

        // Listen for messages
        const messageDisposable = panel.webview.onDidReceiveMessage(async (message: Record<string, unknown>) => {
            console.log(`[TaskPlanner] Received message: ${JSON.stringify(message)}`);

            for (const handler of handlers) {
                if (message.type === handler.type) {
                    const result = await handler.handle(message);
                    if (result !== undefined) {
                        safeResolve(result);
                        return;
                    }
                }
            }
        });
        disposables.push(messageDisposable);

        // Handle panel disposal
        const panelDisposable = panel.onDidDispose(() => {
            console.log('[TaskPlanner] Panel disposed while waiting');
            safeResolve(null);
        });
        disposables.push(panelDisposable);

        // Handle cancellation
        const tokenDisposable = token.onCancellationRequested(() => {
            console.log('[TaskPlanner] Cancellation requested');
            safeResolve(null);
        });
        disposables.push(tokenDisposable);
    });
}

/**
 * Task Planner Tool
 * Uses runSubagent + single persistent Webview for dynamic interactive question flow
 */
class TaskPlannerTool implements vscode.LanguageModelTool<PlanToolInput> {

    async invoke(
        options: vscode.LanguageModelToolInvocationOptions<PlanToolInput>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        const { userRequest, context } = options.input;
        console.log(`[TaskPlanner] invoke called with userRequest: ${userRequest}`);

        // Clean the user request to remove tool name prefix
        const cleanRequest = this.cleanUserRequest(userRequest);
        console.log(`[TaskPlanner] cleanRequest: ${cleanRequest}`);

        const collectedAnswers: CollectedAnswer[] = [];

        try {
            // Step 1: Analyze workspace context
            console.log('[TaskPlanner] Step 1: Analyzing workspace context...');
            const workspaceContext = await this.analyzeWorkspaceContext(
                cleanRequest,
                options.toolInvocationToken,
                token
            );
            const fullContext = workspaceContext || context || '';
            console.log(`[TaskPlanner] Workspace context length: ${fullContext.length}`);

            // Step 2: Create persistent Webview panel
            console.log('[TaskPlanner] Step 2: Creating Webview panel...');
            const panel = vscode.window.createWebviewPanel(
                'taskPlanner',
                'Task Planner',
                vscode.ViewColumn.One,
                { enableScripts: true }
            );
            console.log('[TaskPlanner] Webview panel created');

            // Initialize the panel with base HTML
            panel.webview.html = this.generateBaseHtml(cleanRequest);
            console.log('[TaskPlanner] Webview HTML set');

            // Create a promise that resolves when panel is closed or user finishes
            let panelClosed = false;
            panel.onDidDispose(() => {
                console.log('[TaskPlanner] Panel disposed');
                panelClosed = true;
            });

            // Step 3: Dynamic question loop with back support
            console.log('[TaskPlanner] Step 3: Starting question loop...');
            const questionHistory: { question: Question; response: QuestionResponse }[] = [];
            let currentIndex = 0;

            while (currentIndex < Config.MAX_QUESTIONS) {
                console.log(`[TaskPlanner] Question loop iteration ${currentIndex + 1}`);

                if (token.isCancellationRequested) {
                    console.log('[TaskPlanner] Cancellation requested');
                    break;
                }
                if (panelClosed) {
                    console.log('[TaskPlanner] Panel was closed');
                    break;
                }

                let questionResponse: QuestionResponse;

                // Check if we're revisiting a previous question
                if (currentIndex < questionHistory.length) {
                    console.log('[TaskPlanner] Using cached question');
                    questionResponse = questionHistory[currentIndex].response;
                } else {
                    // Generate new question based on answers up to current index
                    console.log('[TaskPlanner] Generating new question...');
                    const answersForGeneration = collectedAnswers.slice(0, currentIndex);
                    questionResponse = await this.generateNextQuestion(
                        cleanRequest,
                        fullContext,
                        answersForGeneration,
                        options.toolInvocationToken,
                        token
                    );
                    console.log(`[TaskPlanner] Question response: done=${questionResponse.done}, hasQuestion=${!!questionResponse.question}`);

                    // Check if we have enough information
                    if (questionResponse.done || !questionResponse.question) {
                        console.log(`[TaskPlanner] Breaking loop: done=${questionResponse.done}, reason=${questionResponse.reason}`);
                        break;
                    }

                    // Cache the question
                    questionHistory.push({ question: questionResponse.question, response: questionResponse });
                    console.log(`[TaskPlanner] Cached question: ${questionResponse.question.text}`);
                }

                if (!questionResponse.question) {
                    console.log('[TaskPlanner] No question in response, breaking');
                    break;
                }

                // Send question to Webview and wait for answer
                console.log(`[TaskPlanner] Sending question to Webview: ${questionResponse.question.text}`);
                const result = await this.askQuestionInPanel(
                    panel,
                    questionResponse.question,
                    currentIndex + 1,
                    currentIndex > 0, // canGoBack
                    token
                );
                console.log(`[TaskPlanner] Got result from panel: ${result}`);

                if (result === null) {
                    console.log('[TaskPlanner] User cancelled');
                    panel.dispose();
                    return new vscode.LanguageModelToolResult([
                        new vscode.LanguageModelTextPart('User cancelled the planning process.')
                    ]);
                }

                if (result === '__BACK__') {
                    console.log('[TaskPlanner] User went back');
                    if (currentIndex > 0) {
                        currentIndex--;
                        collectedAnswers.pop();
                        safePostMessage(panel, { type: ExtensionMessage.REMOVE_LAST_QA });
                    }
                    continue;
                }

                // Store or update answer
                if (currentIndex < collectedAnswers.length) {
                    collectedAnswers[currentIndex] = {
                        question: questionResponse.question.text,
                        answer: result
                    };
                } else {
                    collectedAnswers.push({
                        question: questionResponse.question.text,
                        answer: result
                    });
                }
                console.log(`[TaskPlanner] Stored answer ${currentIndex + 1}: ${result}`);

                // Update panel to show the answered question
                safePostMessage(panel, {
                    type: ExtensionMessage.QUESTION_ANSWERED,
                    questionNum: currentIndex + 1,
                    question: questionResponse.question.text,
                    answer: result
                });

                currentIndex++;
            }

            console.log(`[TaskPlanner] Question loop finished. Collected ${collectedAnswers.length} answers`);

            // Send completion message to panel
            safePostMessage(panel, { type: ExtensionMessage.GENERATING });

            // Step 4: Generate and confirm refined prompt
            console.log('[TaskPlanner] Step 4: Generating refined prompt...');
            let refinedPrompt = await this.generateRefinedPrompt(
                cleanRequest,
                fullContext,
                collectedAnswers,
                options.toolInvocationToken,
                token
            );
            console.log(`[TaskPlanner] Refined prompt length: ${refinedPrompt.length}`);

            // Step 5: Plan confirmation loop
            console.log('[TaskPlanner] Step 5: Plan confirmation loop...');
            let confirmed = false;
            while (!confirmed && !panelClosed && !token.isCancellationRequested) {
                const confirmResult = await this.showPlanConfirmation(panel, refinedPrompt, options.toolInvocationToken, token);
                console.log(`[TaskPlanner] Confirmation result: ${confirmResult?.type}`);

                if (confirmResult === null) {
                    // User cancelled
                    panel.dispose();
                    return new vscode.LanguageModelToolResult([
                        new vscode.LanguageModelTextPart('User cancelled the planning process.')
                    ]);
                }

                if (confirmResult.type === 'approve') {
                    confirmed = true;
                } else if (confirmResult.type === 'revise' && confirmResult.feedback) {
                    // Revise the plan based on feedback
                    console.log(`[TaskPlanner] Revising plan with feedback: ${confirmResult.feedback}`);
                    safePostMessage(panel, { type: ExtensionMessage.REVISING });

                    refinedPrompt = await this.revisePlan(
                        refinedPrompt,
                        confirmResult.feedback,
                        options.toolInvocationToken,
                        token
                    );
                    console.log(`[TaskPlanner] Revised prompt length: ${refinedPrompt.length}`);
                }
            }

            // Step 6: Register tasks to manage_todo_list
            console.log('[TaskPlanner] Step 6: Registering tasks to todo list...');
            await this.registerTasksToTodoList(
                refinedPrompt,
                options.toolInvocationToken,
                token
            );

            // Close the panel
            console.log('[TaskPlanner] Closing panel');
            panel.dispose();

            console.log('[TaskPlanner] Returning refined prompt');
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(refinedPrompt)
            ]);

        } catch (error) {
            console.error('[TaskPlanner] Error:', error);
            if (error instanceof Error && error.message === 'Cancelled by user') {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('User cancelled the planning process.')
                ]);
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`Error during planning: ${errorMessage}`)
            ]);
        }
    }

    /**
     * Analyzes the current workspace context
     */
    private async analyzeWorkspaceContext(
        userRequest: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string | undefined> {
        try {
            const prompt = `Analyze the current workspace to provide context for implementing: "${userRequest}"

## Analysis Focus
1. **Project Structure**: Identify key directories, entry points, and architectural patterns
2. **Tech Stack**: Detect frameworks, languages, build tools, and dependencies
3. **Relevant Files**: Find files likely to be modified or referenced for this task
4. **Existing Patterns**: Note coding conventions, naming patterns, and design patterns used

## Output Requirements
- Provide a concise summary (max 150 words)
- Focus ONLY on information relevant to the user's request
- Use bullet points for clarity
- Respond in the SAME LANGUAGE as the user's request`;

            const context = await invokeSubagent(
                'Analyze workspace context',
                prompt,
                toolInvocationToken,
                token
            );
            return context || undefined;
        } catch (error) {
            console.error('[TaskPlanner] analyzeWorkspaceContext error:', error);
            return undefined;
        }
    }

    /**
     * Generates the next question based on collected answers
     */
    private async generateNextQuestion(
        userRequest: string,
        context: string,
        collectedAnswers: CollectedAnswer[],
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<QuestionResponse> {
        const answersText = collectedAnswers.length > 0
            ? collectedAnswers.map((a, i) => `Q${i + 1}: ${a.question}\nA${i + 1}: ${a.answer}`).join('\n\n')
            : 'No questions asked yet.';

        const prompt = `You are a task planning assistant. Generate the NEXT clarifying question.

## User Request
${userRequest}

## Context
${context}

## Previous Q&A
${answersText}

## Your Task
Before generating a question, you MAY investigate the workspace or use other tools if needed to understand the project better.
Then decide if you need more information. Ask about:
- Goals and success criteria
- Scope and boundaries
- Technical constraints
- Dependencies or risks

## Language Rule
IMPORTANT: Respond in the SAME LANGUAGE as the user's request. If the user wrote in Japanese, generate the question and options in Japanese. If in English, use English.

## Question Format Rules
- ALWAYS use "select" type with exactly 4 options
- Make options specific and relevant to THIS project based on your investigation
- The 5th "Other" option will be automatically added by the UI

## Output (JSON only)
If enough info: {"done": true, "reason": "brief reason"}
If need more: {"done": false, "question": {"text": "Question?", "type": "select", "options": ["Option 1", "Option 2", "Option 3", "Option 4"] }}

Return ONLY valid JSON.`;

        console.log('[TaskPlanner] generateNextQuestion prompt sent');
        const response = await invokeSubagent(
            'Generate next question',
            prompt,
            toolInvocationToken,
            token
        );
        console.log(`[TaskPlanner] generateNextQuestion raw response: ${response.substring(0, 200)}...`);

        // Validator to ensure the parsed object is a valid QuestionResponse
        const isQuestionResponse = (obj: unknown): obj is QuestionResponse => {
            if (typeof obj !== 'object' || obj === null) return false;
            const o = obj as Record<string, unknown>;
            if (typeof o.done !== 'boolean') return false;
            if (o.question !== undefined) {
                const q = o.question as Record<string, unknown>;
                if (typeof q.text !== 'string' || typeof q.type !== 'string') return false;
            }
            return true;
        };

        const parsed = parseJsonWithRetry<QuestionResponse>(response, isQuestionResponse);
        if (parsed) {
            console.log(`[TaskPlanner] Parsed response: done=${parsed.done}, question=${parsed.question?.text || 'none'}`);
            return parsed;
        }

        console.log('[TaskPlanner] Failed to parse response after retries');
        return { done: true, reason: 'Could not parse response' };
    }

    /**
     * Sends a question to the panel and waits for the answer
     */
    private askQuestionInPanel(
        panel: vscode.WebviewPanel,
        question: Question,
        questionNum: number,
        canGoBack: boolean,
        token: vscode.CancellationToken
    ): Promise<string | null> {
        console.log(`[TaskPlanner] askQuestionInPanel: Q${questionNum}, canGoBack=${canGoBack}`);

        const handlers: MessageHandler<string | null>[] = [
            {
                type: WebviewMessage.ANSWER,
                handle: (msg) => msg.answer as string,
            },
            {
                type: WebviewMessage.BACK,
                handle: () => '__BACK__',
            },
            {
                type: WebviewMessage.CANCEL,
                handle: () => null,
            },
        ];

        return createPanelPromise(panel, handlers, token, () => {
            // Send the new question to the Webview
            console.log('[TaskPlanner] Posting newQuestion message to Webview');
            safePostMessage(panel, {
                type: ExtensionMessage.NEW_QUESTION,
                questionNum,
                question,
                canGoBack
            });
        });
    }

    /**
     * Result type for plan confirmation
     */
    private showPlanConfirmation(
        panel: vscode.WebviewPanel,
        plan: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<{ type: 'approve' | 'revise'; feedback?: string } | null> {
        console.log('[TaskPlanner] showPlanConfirmation');

        // Mutable state for translation
        let currentDisplayPlan = plan;
        let isTranslated = false;

        const sendPlan = () => {
            safePostMessage(panel, {
                type: ExtensionMessage.SHOW_PLAN,
                plan: currentDisplayPlan,
                isTranslated
            });
        };

        type ConfirmResult = { type: 'approve' | 'revise'; feedback?: string };

        const handlers: MessageHandler<ConfirmResult | null>[] = [
            {
                type: WebviewMessage.APPROVE_PLAN,
                handle: () => ({ type: 'approve' as const }),
            },
            {
                type: WebviewMessage.REVISE_PLAN,
                handle: (msg) => ({ type: 'revise' as const, feedback: msg.feedback as string }),
            },
            {
                type: WebviewMessage.TRANSLATE_PLAN,
                handle: async (msg) => {
                    // Translate to user's language (doesn't resolve the promise)
                    safePostMessage(panel, { type: ExtensionMessage.TRANSLATING });
                    try {
                        const translated = await this.translatePlan(
                            plan,
                            msg.targetLang as string,
                            toolInvocationToken,
                            token
                        );
                        currentDisplayPlan = translated;
                        isTranslated = true;
                        sendPlan();
                    } catch (error) {
                        console.error('[TaskPlanner] Translation error:', error);
                        sendPlan(); // Show current plan on error
                    }
                    return undefined; // Don't resolve - continue waiting
                },
            },
            {
                type: WebviewMessage.SHOW_ORIGINAL,
                handle: () => {
                    currentDisplayPlan = plan;
                    isTranslated = false;
                    sendPlan();
                    return undefined; // Don't resolve - continue waiting
                },
            },
            {
                type: WebviewMessage.CANCEL,
                handle: () => null,
            },
        ];

        return createPanelPromise(panel, handlers, token, sendPlan);
    }

    /**
     * Translates the plan to a target language
     */
    private async translatePlan(
        plan: string,
        targetLang: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        console.log(`[TaskPlanner] Translating plan to ${targetLang}`);
        const prompt = `Translate the following task plan to ${targetLang}.

## Translation Rules
1. **Preserve Structure**: Keep all Markdown formatting (headers, lists, code blocks) intact
2. **Technical Terms**: Keep technical terms, code snippets, file paths, and command names in their original form
3. **Consistency**: Maintain consistent terminology throughout the translation
4. **Natural Flow**: Use natural expressions in ${targetLang}, not literal translations

## Task Plan
${plan}

Return ONLY the translated plan with no additional explanations.`;

        const result = await invokeSubagent(
            `Translate plan to ${targetLang}`,
            prompt,
            toolInvocationToken,
            token
        );

        return result || plan;
    }

    /**
     * Revises the plan based on user feedback
     */
    private async revisePlan(
        currentPlan: string,
        feedback: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        const prompt = `Revise the following task plan based on user feedback.

## Current Plan
${currentPlan}

## User Feedback
${feedback}

## Instructions
- Apply the user's feedback to modify the plan
- Keep the same structure and format
- Respond in the same language as the current plan
- Return ONLY the revised plan, no explanations`;

        const result = await invokeSubagent(
            'Revise plan based on feedback',
            prompt,
            toolInvocationToken,
            token
        );

        return result || currentPlan;
    }

    /**
     * Generates the base HTML for the Webview
     */
    private generateBaseHtml(userRequest: string): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Planner</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--vscode-font-family, -apple-system, BlinkMacSystemFont, sans-serif);
            font-size: var(--vscode-font-size, 13px);
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 16px;
            line-height: 1.4;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border));
        }
        .header-icon {
            font-size: 16px;
        }
        .header-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--vscode-foreground);
        }
        .task-info {
            background: var(--vscode-textBlockQuote-background);
            border-left: 2px solid var(--vscode-textLink-activeForeground);
            padding: 8px 12px;
            margin-bottom: 16px;
            font-size: 12px;
            color: var(--vscode-descriptionForeground);
        }
        .task-info strong { color: var(--vscode-foreground); }
        .qa-history { margin-bottom: 12px; }
        .qa-item {
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .qa-item .q {
            color: var(--vscode-textLink-foreground);
            font-weight: 500;
            margin-bottom: 4px;
        }
        .qa-item .a { color: var(--vscode-foreground); }
        .question-panel {
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-focusBorder);
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 12px;
        }
        .question-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--vscode-descriptionForeground);
            margin-bottom: 6px;
        }
        .question-text {
            font-size: 13px;
            color: var(--vscode-foreground);
            margin-bottom: 12px;
            font-weight: 500;
        }
        .options-list { display: flex; flex-direction: column; gap: 6px; }
        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 3px;
            cursor: pointer;
            transition: border-color 0.1s, background 0.1s;
        }
        .option-item:hover {
            background: var(--vscode-list-hoverBackground);
            border-color: var(--vscode-focusBorder);
        }
        .option-item input[type="radio"] {
            accent-color: var(--vscode-focusBorder);
        }
        .option-item.other-option {
            flex-wrap: wrap;
        }
        .option-item.other-option input[type="text"] {
            flex: 1;
            min-width: 150px;
            margin-left: 4px;
        }
        input[type="text"], textarea {
            width: 100%;
            padding: 6px 8px;
            background: var(--vscode-input-background);
            border: 1px solid var(--vscode-input-border);
            color: var(--vscode-input-foreground);
            border-radius: 2px;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }
        input[type="text"]:focus, textarea:focus {
            border-color: var(--vscode-focusBorder);
        }
        textarea { resize: vertical; min-height: 60px; }
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        button {
            padding: 6px 14px;
            border-radius: 2px;
            font-size: 13px;
            cursor: pointer;
            border: none;
            font-family: inherit;
        }
        .btn-primary {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }
        .btn-primary:hover { background: var(--vscode-button-hoverBackground); }
        .btn-secondary {
            background: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        .btn-secondary:hover { background: var(--vscode-button-secondaryHoverBackground); }
        .status-panel {
            display: none;
            text-align: center;
            padding: 24px;
            color: var(--vscode-descriptionForeground);
            font-size: 12px;
        }
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--vscode-input-border);
            border-top-color: var(--vscode-focusBorder);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="header">
        <span class="header-icon">üìã</span>
        <span class="header-title">Task Planner</span>
    </div>
    <div class="task-info">
        <strong>Task:</strong> ${this.escapeHtml(userRequest)}
    </div>
    
    <div id="qa-history" class="qa-history"></div>
    
    <div id="current-question" class="question-panel" style="display: none;">
        <div class="question-label">Question <span id="q-num">1</span></div>
        <div class="question-text" id="q-text"></div>
        <div class="options-list" id="input-area"></div>
        <div class="button-row">
            <button type="button" class="btn-primary" id="submitBtn">Continue</button>
            <button type="button" class="btn-secondary" id="backBtn" style="display: none;">‚Üê Back</button>
        </div>
    </div>
    
    <div id="status" class="status-panel">
        <span class="spinner"></span>
        <span id="status-text">Analyzing workspace...</span>
    </div>
    
    <div id="plan-panel" class="question-panel" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <div class="question-label" style="margin-bottom: 0;">Generated Plan</div>
            <div id="lang-toggle" style="display: flex; gap: 4px; align-items: center;">
                <span style="font-size: 11px; color: var(--vscode-descriptionForeground);">üåê</span>
                <select id="lang-select" style="padding: 4px 8px; font-size: 11px; background: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 2px; cursor: pointer;">
                    <option value="English">English (Original)</option>
                    <option value="Japanese">Êó•Êú¨Ë™û</option>
                    <option value="Chinese Simplified">ÁÆÄ‰Ωì‰∏≠Êñá</option>
                    <option value="Chinese Traditional">ÁπÅÈ´î‰∏≠Êñá</option>
                    <option value="Korean">ÌïúÍµ≠Ïñ¥</option>
                    <option value="French">Fran√ßais</option>
                    <option value="German">Deutsch</option>
                    <option value="Italian">Italiano</option>
                    <option value="Spanish">Espa√±ol</option>
                    <option value="Russian">–†—É—Å—Å–∫–∏–π</option>
                    <option value="Portuguese Brazilian">Portugu√™s (Brasil)</option>
                    <option value="Polish">Polski</option>
                    <option value="Turkish">T√ºrk√ße</option>
                    <option value="Czech">ƒåe≈°tina</option>
                </select>
            </div>
        </div>
        <div id="plan-content" style="white-space: pre-wrap; font-size: 12px; max-height: 400px; overflow-y: auto; background: var(--vscode-editor-background); padding: 12px; border-radius: 4px; margin-bottom: 12px;"></div>
        <div id="feedback-section" style="display: none; margin-bottom: 12px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                <div class="question-label" style="margin-bottom: 0;">Revision Request</div>
                <button type="button" id="feedbackCancelBtn" style="background: none; border: none; color: var(--vscode-descriptionForeground); cursor: pointer; font-size: 12px; padding: 2px 6px;">‚úï Cancel</button>
            </div>
            <textarea id="feedback-text" rows="3" placeholder="Describe how you want to change the plan..."></textarea>
            <div id="feedback-error" style="display: none; color: var(--vscode-errorForeground); font-size: 11px; margin-top: 4px;"></div>
        </div>
        <div class="button-row">
            <button type="button" class="btn-primary" id="approveBtn">‚úì Approve</button>
            <button type="button" class="btn-secondary" id="reviseBtn">‚úé Revise</button>
            <button type="button" class="btn-secondary" id="planCancelBtn">Cancel</button>
        </div>
    </div>
    
    <script>
        const vscode = acquireVsCodeApi();
        const qaHistory = document.getElementById('qa-history');
        const currentQuestion = document.getElementById('current-question');
        const qNum = document.getElementById('q-num');
        const qText = document.getElementById('q-text');
        const inputArea = document.getElementById('input-area');
        const status = document.getElementById('status');
        const statusText = document.getElementById('status-text');
        const submitBtn = document.getElementById('submitBtn');
        const backBtn = document.getElementById('backBtn');

        let currentQuestionData = null;
        
        // Show initial loading state
        status.style.display = 'block';
        
        window.addEventListener('message', event => {
            const message = event.data;
            
            if (message.type === 'newQuestion') {
                currentQuestionData = message.question;
                qNum.textContent = message.questionNum;
                qText.textContent = message.question.text;
                inputArea.innerHTML = createInputField(message.question);
                currentQuestion.style.display = 'block';
                status.style.display = 'none';
                
                // Show/hide back button
                backBtn.style.display = message.canGoBack ? 'inline-block' : 'none';
                
                // Focus on the input
                const input = inputArea.querySelector('input, textarea');
                if (input) input.focus();
            }
            else if (message.type === 'questionAnswered') {
                const item = document.createElement('div');
                item.className = 'qa-item';
                item.innerHTML = '<div class="q">Q' + message.questionNum + ': ' + escapeHtml(message.question) + '</div>' +
                                 '<div class="a">' + escapeHtml(message.answer) + '</div>';
                qaHistory.appendChild(item);
                
                currentQuestion.style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Thinking of next question...';
            }
            else if (message.type === 'removeLastQA') {
                if (qaHistory.lastChild) {
                    qaHistory.removeChild(qaHistory.lastChild);
                }
            }
            else if (message.type === 'generating') {
                currentQuestion.style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Generating detailed plan...';
            }
            else if (message.type === 'showPlan') {
                currentQuestion.style.display = 'none';
                status.style.display = 'none';
                document.getElementById('plan-panel').style.display = 'block';
                document.getElementById('plan-content').textContent = message.plan;
                document.getElementById('feedback-section').style.display = 'none';
                document.getElementById('feedback-text').value = '';
                document.getElementById('feedback-error').style.display = 'none';

                // Reset Revise button to initial state
                const reviseBtn = document.getElementById('reviseBtn');
                reviseBtn.textContent = '‚úé Revise';
                reviseBtn.classList.remove('btn-primary');
                reviseBtn.classList.add('btn-secondary');

                // Update language select to reflect current state
                if (!message.isTranslated) {
                    document.getElementById('lang-select').value = 'English';
                }
            }
            else if (message.type === 'translating') {
                document.getElementById('plan-panel').style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Translating plan...';
            }
            else if (message.type === 'revising') {
                document.getElementById('plan-panel').style.display = 'none';
                status.style.display = 'block';
                statusText.textContent = 'Revising plan based on feedback...';
            }
        });
        
        backBtn.addEventListener('click', () => {
            vscode.postMessage({ type: 'back' });
        });
        
        document.getElementById('approveBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'approvePlan' });
        });
        
        document.getElementById('reviseBtn').addEventListener('click', () => {
            const feedbackSection = document.getElementById('feedback-section');
            const feedbackText = document.getElementById('feedback-text');
            const feedbackError = document.getElementById('feedback-error');
            const reviseBtn = document.getElementById('reviseBtn');

            if (feedbackSection.style.display === 'none') {
                // Show feedback section and change button text
                feedbackSection.style.display = 'block';
                reviseBtn.textContent = 'üì§ Send Revision';
                reviseBtn.classList.remove('btn-secondary');
                reviseBtn.classList.add('btn-primary');
                feedbackError.style.display = 'none';
                feedbackText.focus();
            } else {
                const feedback = feedbackText.value.trim();
                if (feedback) {
                    feedbackError.style.display = 'none';
                    vscode.postMessage({ type: 'revisePlan', feedback: feedback });
                } else {
                    // Show error for empty feedback
                    feedbackError.textContent = 'Please enter your revision request.';
                    feedbackError.style.display = 'block';
                    feedbackText.focus();
                }
            }
        });
        
        document.getElementById('planCancelBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'cancel' });
        });

        document.getElementById('feedbackCancelBtn').addEventListener('click', () => {
            const feedbackSection = document.getElementById('feedback-section');
            const feedbackText = document.getElementById('feedback-text');
            const feedbackError = document.getElementById('feedback-error');
            const reviseBtn = document.getElementById('reviseBtn');

            // Hide feedback section and reset button
            feedbackSection.style.display = 'none';
            feedbackText.value = '';
            feedbackError.style.display = 'none';
            reviseBtn.textContent = '‚úé Revise';
            reviseBtn.classList.remove('btn-primary');
            reviseBtn.classList.add('btn-secondary');
        });

        document.getElementById('lang-select').addEventListener('change', (e) => {
            const lang = e.target.value;
            if (lang === 'English') {
                vscode.postMessage({ type: 'showOriginal' });
            } else {
                vscode.postMessage({ type: 'translatePlan', targetLang: lang });
            }
        });
        
        function createInputField(question) {
            if (question.type === 'select' && question.options) {
                return question.options.map(opt => 
                    '<label class="option-item"><input type="radio" name="answer" value="' + escapeHtml(opt) + '"> ' + escapeHtml(opt) + '</label>'
                ).join('') +
                '<label class="option-item other-option"><input type="radio" name="answer" value="__OTHER__"> Other: <input type="text" id="other-text" placeholder="Enter your answer..." onclick="document.querySelector(\\'input[value=__OTHER__]\\').checked = true;"></label>';
            } else if (question.type === 'multiline') {
                return '<textarea id="answer" rows="3" placeholder="Your answer..."></textarea>';
            } else {
                return '<input type="text" id="answer" placeholder="Your answer...">';
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function getAnswer() {
            const radio = inputArea.querySelector('input[type="radio"]:checked');
            if (radio) {
                if (radio.value === '__OTHER__') {
                    const otherText = document.getElementById('other-text');
                    return otherText ? otherText.value : '';
                }
                return radio.value;
            }
            const input = inputArea.querySelector('input, textarea');
            return input ? input.value : '';
        }
        
        submitBtn.addEventListener('click', () => {
            const answer = getAnswer();
            if (answer.trim()) {
                vscode.postMessage({ type: 'answer', answer: answer });
            }
        });
        
        // Handle Enter key for text inputs
        inputArea.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && currentQuestionData?.type !== 'multiline') {
                e.preventDefault();
                submitBtn.click();
            }
        });
    </script>
</body>
</html>`;
    }

    /**
     * Cleans the user request by removing tool name prefixes
     */
    private cleanUserRequest(request: string): string {
        return request
            .replace(/^#?plan\s*/i, '')  // Remove #plan or plan prefix
            .replace(/^['"]plan['"]\s*/i, '')  // Remove 'plan' or "plan" prefix
            .trim();
    }

    private escapeHtml(text: string): string {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    /**
     * Generates the final refined prompt
     */
    private async generateRefinedPrompt(
        userRequest: string,
        context: string,
        answers: CollectedAnswer[],
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<string> {
        const answersText = answers.map((a, i) => `Q${i + 1}: ${a.question}\nA${i + 1}: ${a.answer}`).join('\n\n');
        const bq = '`';
        const mdBlock = bq + bq + bq;

        const prompt = `Generate a comprehensive, actionable task plan based on the gathered information.

## User Request
${userRequest}

## Workspace Context
${context}

## Clarifying Q&A
${answersText}

## Language Rule
IMPORTANT: Always generate the plan in ENGLISH, regardless of the user's language.

## Output Format
${mdBlock}
# Task: [Concise task name]

## Overview
[1-2 sentences: What will be implemented and why it's needed]

## Goals
- [Specific, measurable goal 1]
- [Specific, measurable goal 2]

## Scope
- [Specific files/directories to modify]
- [What is OUT of scope]

## Approach
- [Key technical decisions and why]
- [Libraries/APIs to use]

## Completion Criteria
- [How to verify the task is complete]
- [Tests or checks to run]

## Steps
1. [Atomic, actionable step - should take ~5-15 min each]
2. [Next step...]
${mdBlock}

## Guidelines
- Make each step atomic and independently verifiable
- Include specific file paths when known
- Steps should be 5-15 minutes of work each
- Aim for 3-8 steps total`;

        const result = await invokeSubagent(
            'Generate task prompt',
            prompt,
            toolInvocationToken,
            token
        );

        if (!result) throw new Error('No response');
        return result;
    }

    /**
     * Registers tasks to the manage_todo_list tool via runSubagent
     */
    private async registerTasksToTodoList(
        refinedPrompt: string,
        toolInvocationToken: vscode.ChatParticipantToolToken | undefined,
        token: vscode.CancellationToken
    ): Promise<void> {
        try {
            const prompt = `You are a task registration assistant.

Extract the implementation steps from the following task plan and register each step as a todo item using the manage_todo_list tool.

## Task Plan
${refinedPrompt}

## Instructions
1. Extract all numbered steps from the "## Steps" section
2. Use the manage_todo_list tool to add each step as a todo item
3. After registering, confirm completion

Do NOT output the full plan in chat. Just register the todos and confirm.`;

            await invokeSubagent(
                'Register tasks to todo list',
                prompt,
                toolInvocationToken,
                token
            );

            console.log('[TaskPlanner] Registered tasks to todo list via subagent');
        } catch (error) {
            console.error('[TaskPlanner] Failed to register tasks to todo list:', error);
        }
    }

    async prepareInvocation(
        options: vscode.LanguageModelToolInvocationPrepareOptions<PlanToolInput>,
        _token: vscode.CancellationToken
    ): Promise<vscode.PreparedToolInvocation> {
        const { userRequest } = options.input;
        return {
            invocationMessage: `Planning: "${userRequest.substring(0, 50)}${userRequest.length > 50 ? '...' : ''}"`,
        };
    }
}

export function activate(context: vscode.ExtensionContext) {
    console.log('[TaskPlanner] Extension activated');
    const tool = new TaskPlannerTool();
    context.subscriptions.push(vscode.lm.registerTool('plan', tool));
}

export function deactivate() {
    console.log('[TaskPlanner] Extension deactivated');
}
